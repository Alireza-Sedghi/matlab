function [ac_X ac_Y ac_Z ac_T ac_R ac_S ac_c ] = ...
				dijkstra_clusterMeta(str_target, varargin)
%
% NAME
%
%  	function [ac_X ac_Y ac_Z ac_T ac_R ac_S ac_c ] = ...
%  				dijkstra_clusterMeta(str_target [,	   ...
%							 <distanceMetric>, ...
%							 <linkageMetric>,  ...
%							 <cutOff>,	   ...
%							 <criterion>,	   ...
%							 <depth>])
%
% ARGUMENTS
%	INPUT
%	str_target	string		an ls compatible string defining a 
%					pattern of target files to process.
%	distanceMetric	string		passed to 'pdist'.
%	linkageMetric	string		passed to 'linkage'.
%	cutOff		double		cutOff is a threshold for cutting the
%					hierarchical tree generated by linkage 
%					into clusters. When 0 < cutOff < 1, 
%					clusters are formed when inconsistent 
%					values are greater than cutoff 
%					(see the inconsistent function). When 
%					cutOff is an integer and cutOff >= 2, 
%					then cutoff as the maximum number of 
%					clusters to keep in the hierarchical 
%					tree generated by linkage.
%	criterion	string		either 'distance' or 'inconsistent'.
%	depth		int		evaluate inconsistent to given depth.
%			
%	OUTPUT
%	ac_X		cell matrix	the core matrix of weights, pruned from
%					<str_fileName>, size m-by-n matrix, 
%					treated as m observations of n 
%					variables.
%	ac_Y		cell matrix	the 'distance' between objects in <X>.
%	ac_Z		cell matrix	the 'linkage' between distances in <Y>.
%	ac_T		cell vector	vector of size m containing a cluster 
%					number for each observation.
%	ac_R		cell matrix	a 'report' matrix that contains all the
%					vectors in X that satisfy the cluster
%					cutOff constraint in T.
%	ac_S		cell vector	a 'summary' vector produced by calling
%					dijkstra_weightProc(...)
%	ac_c		cell float	correlation between clustered group and
%					template vector.
%
% DESCRIPTION
%
%	'dijkstra_clusterMeta' is a thin wrapper around an underlying script,
%	'dijkstra_clusterFromFile' and as such preserves the same input 
%	arguments. The outputs are cell-based, with one cell for each file
%	that satisfies the <str_target> argument.
%
% PRECONDITIONS
%
%	o <str_target> is ls-compatible, i.e. '*.log' or 'rh_*.log'.
%	o LABEL_set bash script in PATH.
%	o Assumes a UNIX/Linux runtime.
%
% POSTCONDITIONS
%
%	o Output returns can be further processed, as with 'dendogram(Z)'.
%
%
% HISTORY
% 19 January 2006
% o Initial design and coding.
%


%%%%%%%%%%%%%% 
%%% Nested functions
%%%%%%%%%%%%%% 
	function error_exit(	str_action, str_msg, str_ret)
		fprintf(1, '\tFATAL:\n');
		fprintf(1, '\tSorry, some error has occurred.\n');
		fprintf(1, '\tWhile %s,\n', str_action);
		fprintf(1, '\t%s\n', str_msg);
		error(str_ret);
	end

	function vprintf(level, str_msg)
	    if verbosity >= level
		fprintf(1, str_msg);
	    end
	end

	function str_alpha = squash(str_in)
		str_squashCMD 	= sprintf('echo %s|sed "s| ||g"|sed "s|\\[||"|sed "s|\\]||"', ...
						str_in);
		[ret str_alpha]	= unix(str_squashCMD);
	end

	function m_Xmin = X_sort(m_X)
		%
		% PRECONDITIONS
		% o m_X, an unsorted matrix of weight vectors and fitness.
	 	% o Assumes that the fitness value is in column 9.
		%
		% POSTCONDITIONS
		% o m_Xmin, the minimum fitness and weights of m_X. If 
		%   several weights have this minimum, return a matrix
		%   of these weights, otherwise a vector of the minimum
		%   only.
		%
		m_Xc	= m_X;
		m_Xcs	= sortrows(m_Xc, 9);
		v_fs	= m_Xcs(:, 9);
		m_Xmin	= m_Xcs(1:sum(v_fs==v_fs(1)), :);
	end

	function templateWGHT_process(str_labelFileName, m_X, f_min, str_dsh)
		%
		% PRECONDITIONS
		% o m_X, a vector of weights with objective f_min
		% o m_X might contain multiple weight strings with
		%   same f_min
		%
		% POSTCONDITIONS
		% o For each row of duplicate minimum f_min, call
		%   min_binaryWGHT_create
		%

		[rows cols] = size(m_X);
		for row=1:rows
			v_X 		= m_X(row, 2:9);
			penalty 	= m_X(row, 1);
			str_comment	= '#';
			if penalty
			    str_comment	= '"# binPenal_ON"';
			else
			    str_comment = '"# binPenal_OFF"';
			end
			templateWGHT_appendFile(str_labelFileName, 	...
						v_X, f_min, str_dsh, 	...
						str_comment);
		end
	end

	function templateWGHT_appendFile(str_labelFileName, v_X, f_min,	...
						str_dsh, str_comment)
	    str_XtemMat		= mat2str(v_X);
	    str_XtemRet		= squash(str_XtemMat);
	    [str_Xtem, r]	= strtok(str_XtemRet, char(10));
	    str_temBinaryWGHT = ...
	    sprintf('min_binaryWGHT_create.bash -r %s -w %s -f %f -d %s -p %s', ...
						str_labelFileName,	...
						str_Xtem,		...
						f_min,			...
						str_dsh,		...
						str_comment);
	    [status result]	= unix(str_temBinaryWGHT, '-echo');
	end

	function templateWGHT_processLABEL(str_labelFileName, str_dshName)
		str_LABEL = ...
		sprintf('LABEL_set -d %s %s', str_dshName, str_labelFileName);
		[status result]		= unix(str_LABEL, '-echo');
	end

	function log2mat_strip(str_fileStem)
		% 
		% Removes the first column from <str_fileStem>.log and writes
		% to <str_fileStem>.mat
		%
		str_source = sprintf('%s.log', str_fileStem);
		str_target = sprintf('%s.mat', str_fileStem);
		str_strip = ...
		sprintf('awk ''{for(i=2; i<=NF; i++) printf("%%s\\t", $i); printf("\\n");}'' %s > %s', ...
			str_source, str_target);
		[status results]	= unix(str_strip, '-echo');
	end

	function stats_process(str_fileStem, v_S, c)
		str_target 	= sprintf('%s.mat', str_fileStem);
		str_sum		= sprintf('%s.sum.txt', str_fileStem);
		fid		= fopen(str_sum, 'w');
		X 		= load(str_target, '-ascii');
		W		= X(:, 3:12);
		bv_median	= median(W);
		fv_mean		= mean(W);
		fv_std		= std(W);
		fprintf(fid, '%-15s: correlation within cluster to template:\t%f\n',	...
		str_fileStem, c);
		fprintf(fid, 'template:\t');
		fprintf(fid, '%-10d', v_S);		fprintf(fid, '\n');
		fprintf(fid, 'median:\t\t'); 
		fprintf(fid, '%-10d', bv_median(1:9));	
		fprintf(fid, '%-10f\n', bv_median(10));
		fprintf(fid, 'mean:\t\t'); 
		fprintf(fid, '%-10f', fv_mean(1:10)); 	fprintf(fid, '\n');	
		fprintf(fid, 'std:\t\t'); 
		fprintf(fid, '%-10f', fv_std(1:10)); 	fprintf(fid, '\n');	
		fclose(fid);
	end

%%%%%%%%%%%%%% 
%%%%%%%%%%%%%% 

%
% Parse inputs
%
str_pdistMetric		= 'euclid';
str_linkageMetric	= 'single';
cutOff			= 0.9;
b_maxSpecified		= 0;
str_criterion		= 'inconsistent';
depth			= 2;

if length(varargin)
	str_pdistMetric			= varargin{1};
	if length(varargin) >= 2
		str_linkageMetric	= varargin{2};
	end
	if length(varargin) >= 3
		cutOff			= varargin{3};
	end
	if length(varargin) >= 4
		str_criterion		= varargin{4};
	end
	if length(varargin) >= 5
		depth			= varargin{5};
	end
end

%	
% Search for hits that satisfy <str_target> and allocate memory cells.
%
topLevelDir		= './';
str_findCMD		= sprintf('find $(pwd) -name "%s"', str_target);
str_findHits		= sprintf('find $(pwd) -name "%s" | wc -l', str_target);
[ret str_targetFiles]	= system(str_findCMD);
[ret str_hits]		= system(str_findHits);
hits			= sscanf(str_hits, '%d');
if ~sum(size(str_targetFiles))
	fprintf(1, 'No %s files were found!\nSearch directory: %s\n', str_target, topLevelDir);
	fprintf(1, '\tReturning to MatLAB with return value 0.\n\n');
	return;
end

ac_X			= cell(1, hits);
ac_Y			= cell(1, hits);
ac_Z			= cell(1, hits);
ac_T			= cell(1, hits);
ac_R			= cell(1, hits);
ac_S			= cell(1, hits);
ac_c			= cell(1, hits);

%
% Process each file hit by the search...
%
errcount			= 0;
c				= 0;
[str_targetFile str_rem]	= strtok(str_targetFiles, char(10));
f_min				= -1;
while length(str_rem)
	if strcmp(basename(str_targetFile), 'sapex_metaCtl.bash.log')
		[str_targetFile str_rem] 	= strtok(str_rem, char(10));
		continue
	end
	c		= c+1;
%  	fprintf(1, 'Processing target %s\n', str_targetFile)
	[ac_X{c} ac_Y{c} ac_Z{c} ac_T{c} ac_R{c} ac_S{c} ac_c{c}] = 	...
			dijkstra_clusterFromFile(str_targetFile,	...		
						 str_pdistMetric,	...
						 str_linkageMetric,	...
						 cutOff,		...
						 str_criterion,		...
						 depth);
	str_basenameCMD		= sprintf('basename %s .log | tr -d "\n"', str_targetFile);
	[ret str_stem]		= system(str_basenameCMD);
	str_stem		= sprintf('%d - %s', c, str_stem);
	fprintf(1, '%-15s: correlation within cluster to template:\t%f\n',	...
		str_stem, ac_c{c});
	str_basenameCMD		= sprintf('basename %s .log | tr -d "\n"', str_targetFile);
	[ret str_stem]		= system(str_basenameCMD);
	str_labelFileName	= sprintf('./%s-1.label', str_stem);
	str_dshName		= sprintf('%s-templateWGHT.dsh', str_stem);
  	templateWGHT_process(str_labelFileName, ac_S{c}, f_min,		...
  				 str_dshName);
	templateWGHT_processLABEL(str_labelFileName, str_dshName);
	log2mat_strip(str_stem);
	stats_process(str_stem, ac_S{c}, ac_c{c});
	[str_targetFile str_rem] 	= strtok(str_rem, char(10));
end

end

