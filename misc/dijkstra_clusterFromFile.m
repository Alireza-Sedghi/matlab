function [X Y Z T R S c] = dijkstra_clusterFromFile(str_fileName, varargin)
%
% NAME
%
%	function [X Y Z T R S c] = dijkstra_clusterFromFile(str_fileName [,  ...
%							 <distanceMetric>, ...
%							 <linkageMetric>,  ...
%							 <cutOff>,	   ...
%							 <criterion>,	   ...
%							 <depth>])
%
% ARGUMENTS
%	INPUT
%	str_fileName	string		'dsh' generated filename that contains
%					weight patterns that minimise a given
%					sulcus pattern.
%	distanceMetric	string		passed to 'pdist'.
%	linkageMetric	string		passed to 'linkage'.
%	cutOff		double		cutoff is a threshold for cutting the
%					hierarchical tree generated by linkage 
%					into clusters. When 0 < cutoff < 1, 
%					clusters are formed when inconsistent 
%					values are greater than cutoff 
%					(see the inconsistent function). When 
%					cutoff is an integer and cutoff >= 2, 
%					then cutoff as the maximum number of 
%					clusters to keep in the hierarchical 
%					tree generated by linkage.
%	criterion	string		either 'distance' or 'inconsistent'.
%	depth		int		evaluate inconsistent to given depth.
%			
%	OUTPUT
%	X		matrix		the core matrix of weights, pruned from
%					<str_fileName>, size m-by-n matrix, 
%					treated as m observations of n 
%					variables.
%	Y		matrix		the 'distance' between objects in <X>.
%	Z		matrix		the 'linkage' between distances in <Y>.
%	T		vector		vector of size m containing a cluster 
%					number for each observation.
%	R		matrix		a 'report' matrix that contains all the
%					vectors in X that satisfy the cluster
%					cutoff constraint in T.
%	S		vector		a 'summary' vector produced by calling
%					dijkstra_weightProc(...)
%	c		float		correlation between clustered group and
%					template vector.
%
% DESCRIPTION
%
%	'dijkstra_clusterFromFile' is a simple front end to a straightforward
%	clustering run. Its purpose is to cluster weights from <str_fileName>
%	so that a similarity analysis can be performed.
%
%	In some respects, it is little more than an explicit 'clusterdata()'
%	function call, although it returns the intermediate matrices for
%	possible further processing.
%
% PRECONDITIONS
%
%	o <str_fileName> is a 'dsh' generated log file of weight patterns.
%
%	o Assumes a UNIX/Linux runtime.
%
% POSTCONDITIONS
%
%	o Output returns can be further processed, as with 'dendogram(Z)'.
%
%
% HISTORY
% 18 October 2005
% o Initial design and coding.
%
% 17 January 2006
% o 'R' report matrix.
%
% 18 January 2006
% o Additional varargs to control inner function calls.
%

str_pdistMetric		= 'euclid';
str_linkageMetric	= 'single';
cutOff			= 0.9;
b_maxSpecified		= 0;
str_criterion		= 'inconsistent';
depth			= 2;

%%%%%%%%%%%%%% 
%%% Nested functions
%%%%%%%%%%%%%% 
	function error_exit(	str_action, str_msg, str_ret)
		fprintf(1, '\tFATAL:\n');
		fprintf(1, '\tSorry, some error has occurred.\n');
		fprintf(1, '\tWhile %s,\n', str_action);
		fprintf(1, '\t%s\n', str_msg);
		error(str_ret);
	end

	function vprintf(level, str_msg)
	    if verbosity >= level
		fprintf(1, str_msg);
	    end
	end
%%%%%%%%%%%%%% 
%%%%%%%%%%%%%% 

if length(varargin)
	str_pdistMetric			= varargin{1};
	if length(varargin) >= 2
		str_linkageMetric	= varargin{2};
	end
	if length(varargin) >= 3
		val			= varargin{3};
		if val >= 2
			b_maxSpecified 	= 1;
			maxCluster	= val;
		else
			cutOff		= val;
		end		
	end
	if length(varargin) >= 4
		str_criterion		= varargin{4};
	end
	if length(varargin) >= 5
		depth			= varargin{5};
	end
end


%	
% Process <str_fileName> by stripping out columns 4 to 12 inclusive 
%
str_wc			= sprintf('wc -l %s | awk %s{print $1}%s', ...
				  str_fileName, char(39), char(39));
[ret str_rows]		= system(str_wc);
rows			= sscanf(str_rows, '%d');
X			= zeros(rows, 9);
Y			= 0;
Z			= 0;
T			= 0;
str_stripCMD		= sprintf('cat %s ', str_fileName);
str_stripCMD		= [ str_stripCMD '| awk ' char(39) '{print '];
str_stripCMD		= [ str_stripCMD '$4 	"\t" $5 "\t"' ];
str_stripCMD		= [ str_stripCMD '$6 	"\t" $7 "\t"' ];
str_stripCMD		= [ str_stripCMD '$8 	"\t" $9 "\t"' ];
str_stripCMD		= [ str_stripCMD '$10 	"\t" $11 "\t"' ];
str_stripCMD		= [ str_stripCMD '$12}' char(39) ];;
%str_stripCMD		= [ str_stripCMD '$12	"\t" $13}' char(39) ];;
[ret str_X]		= system(str_stripCMD);
%X			= strread(str_X);
X			= sscanf(str_X, '%d', [9 rows]);
X			= X';

Y 			= pdist(X,   str_pdistMetric);
Z 			= linkage(Y, str_linkageMetric);
if b_maxSpecified
	T		= cluster(Z, 'maxclust', maxCluster);
else
	T		= cluster(Z, 'cutoff', cutOff);
end

%  Y 			= pdist(X,   'euclid');
%Z 			= linkage(Y, 'single');
%T 			= cluster(Z, 'cutoff', cutoff);

[rowsX colsX]		= size(X);
rowsM			= 0;
colsM			= 0;
index			= 0;
for i=1:rowsX
	mi		= find(T==i);
	[rowsI colsI]	= size(mi);
	if rowsI > rowsM
		rowsM	= rowsI;
		index	= i;
	end
end

mT			= find(T==index);
[rowsM colsM]		= size(mT);
R			= zeros(rowsM, colsX);
for i=1:rowsM
	R(i,:)		= X(mT(i),:);
end

S			= dijkstra_weightProc(X);

correlMax 		= 0;
for i=1:rowsM
	correl=sum(~xor(S, R(i,:)));
	if correl > correlMax
		correlMax = correl;
	end
end
correlMax 		= correlMax / colsX;

c			= correlMax;
end

